<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Claude Vision (Ultra)</title>

  <script src="https://js.puter.com/v2/"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #0b0b0d;
      --panel:#111114;
      --panel2:#15151a;
      --border:#26262d;
      --text:#e9e9ef;
      --muted:#a1a1b3;
      --muted2:#707085;
      --accent:#d4a574;
      --danger:#ff6b6b;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 800px at 30% -10%, rgba(212,165,116,.12), transparent 60%),
        radial-gradient(1200px 800px at 90% 10%, rgba(128,90,213,.12), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    .topbar{
      position: sticky; top:0; z-index: 10;
      backdrop-filter: blur(14px);
      background: rgba(11,11,13,.75);
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner{
      max-width: 920px; margin: 0 auto;
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700; }
    .badge{
      width: 34px; height: 34px; border-radius: 10px;
      display:grid; place-items:center;
      background: linear-gradient(135deg, var(--accent), #b98257);
      color:#141414; font-weight:900;
    }
    select{
      appearance:none;
      background: var(--panel2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      outline: none;
    }
    select:hover{ border-color: rgba(212,165,116,.55); }

    .wrap{
      max-width: 920px;
      margin: 0 auto;
      padding: 18px 16px 24px;
      height: calc(100% - 64px);
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .chat{ flex:1; overflow:auto; padding: 6px 0 18px; }
    .welcome{
      margin-top: 40px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border-radius: 18px;
      padding: 22px;
    }
    .welcome h1{ margin: 0 0 10px; font-size: 22px; }
    .welcome p{ margin: 0; color: var(--muted); line-height: 1.55; font-size: 14px; }

    .msg{ margin: 18px 0; display:flex; gap:12px; align-items:flex-start; }
    .avatar{
      width:34px; height:34px; border-radius:11px;
      display:grid; place-items:center;
      flex: 0 0 auto;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      font-weight: 800;
      user-select:none;
    }
    .avatar.assistant{
      background: linear-gradient(135deg, rgba(212,165,116,.95), rgba(185,130,87,.95));
      color:#131313;
      border-color: rgba(212,165,116,.35);
    }
    .bubble{ flex:1 1 auto; min-width:0; }
    .meta{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; color: var(--muted2);
      margin-bottom: 6px;
    }
    .meta .name{ color: var(--text); font-weight: 600; font-size: 13px; }
    .content{
      line-height: 1.75;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .content code{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 2px 6px;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 13px;
    }
    .content pre{
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      padding: 12px;
      border-radius: 14px;
      overflow:auto;
    }

    .images-row{ display:flex; flex-wrap:wrap; gap:10px; margin:10px 0 8px; }
    .thumb{
      width:220px; max-width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.02);
      object-fit: cover;
      cursor:pointer;
    }

    .composer{
      position: sticky; bottom:0;
      padding-top: 10px;
      background: linear-gradient(180deg, transparent, rgba(11,11,13,.85) 30%, rgba(11,11,13,.95));
    }
    .composer-box{
      border: 1px solid var(--border);
      background: rgba(17,17,20,.9);
      border-radius: 18px;
      padding: 14px;
    }
    .composer-box:focus-within{
      border-color: rgba(212,165,116,.55);
      box-shadow: 0 0 0 3px rgba(212,165,116,.10);
    }

    .preview{
      display:none;
      gap:10px;
      flex-wrap: wrap;
      padding-bottom: 12px;
      margin-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .preview.active{ display:flex; }
    .preview-item{
      position: relative;
      width: 76px; height: 76px;
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .preview-item img{ width:100%; height:100%; object-fit: cover; display:block; }
    .preview-remove{
      position:absolute; top:-8px; right:-8px;
      width:24px; height:24px;
      border-radius: 999px;
      border:none;
      background: var(--danger);
      color:#121212;
      font-weight: 900;
      cursor:pointer;
    }

    .row{ display:flex; gap:10px; align-items:flex-end; }
    textarea{
      flex:1 1 auto;
      background: transparent;
      border:none;
      color: var(--text);
      resize:none;
      outline:none;
      font-size: 14px;
      line-height: 1.5;
      min-height: 24px;
      max-height: 180px;
      padding: 2px 0;
    }
    textarea::placeholder{ color: var(--muted2); }

    .btn{
      width:44px; height:44px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size: 14px;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(212,165,116,.55); }

    .btn-send{
      background: linear-gradient(135deg, var(--accent), #b98257);
      border-color: rgba(212,165,116,.50);
      color:#121212;
      font-weight: 900;
      font-size: 18px;
    }
    .btn-send:disabled{ opacity:.55; cursor:not-allowed; }

    .hint{
      margin-top: 10px;
      color: var(--muted2);
      font-size: 12px;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      background: rgba(255,255,255,.03);
      color: var(--muted);
      user-select:none;
    }
    .toggle input{ accent-color: var(--accent); }

    .drop-overlay{
      position: fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      flex-direction:column;
      background: rgba(11,11,13,.92);
      z-index: 100;
      border: 2px dashed rgba(212,165,116,.45);
    }
    .drop-overlay.active{ display:flex; }
    .drop-overlay .big{ font-size:44px; margin-bottom:10px; }
    .drop-overlay .txt{ font-size:16px; color: var(--muted); }

    .modal{
      position: fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.92);
      z-index: 120;
      padding: 24px;
    }
    .modal.active{ display:flex; }
    .modal img{
      max-width:100%;
      max-height:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.15);
      object-fit: contain;
    }
    .modal button{
      position:absolute;
      top: 18px; right: 18px;
      width:46px; height:46px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 20px;
      cursor:pointer;
    }

    @media (max-width: 700px){
      .thumb{ width: 100%; }
      .topbar-inner{ padding: 12px 12px; }
      .wrap{ padding: 14px 12px 18px; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="badge">âœ¦</div>
        <div>Claude Vision</div>
      </div>

      <div class="controls">
        <select id="modelSelect" title="Model">
          <option value="claude-opus-4-5">Claude Opus 4.5</option>
          <option value="claude-sonnet-4-5" selected>Claude Sonnet 4.5</option>
          <option value="claude-haiku-4-5">Claude Haiku 4.5</option>
          <option value="gpt-4o">GPT-4o (backup)</option>
        </select>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div id="chat" class="chat">
      <div class="welcome" id="welcome">
        <h1>Ultra detail + Web lookup</h1>
        <p>
          Upload/paste/drag an image. Ultra mode sends full image + zoomed crops for tiny details.
          The Web button generates an identifying Google query from the image and opens search.
        </p>
      </div>
    </div>

    <div class="composer">
      <div class="composer-box">
        <div id="preview" class="preview"></div>

        <div class="row">
          <textarea id="textInput" rows="1" placeholder="Ask about your imageâ€¦ (Enter to send, Shift+Enter newline)"></textarea>
          <button id="imageBtn" class="btn" title="Image">Image</button>
          <button id="webBtn" class="btn" title="Web">Web</button>
          <button id="sendBtn" class="btn btn-send" title="Send">âž¤</button>
        </div>

        <div class="hint">
          <span><b>Tip:</b> If text is tiny, Ultra mode helps a lot</span>
          <label class="toggle" title="Slower but more detailed (full + crops)">
            <input id="ultraToggle" type="checkbox" checked />
            Ultra detail
          </label>
        </div>
      </div>
    </div>

    <input id="fileInput" type="file" accept="image/*" hidden />
  </div>

  <div id="dropOverlay" class="drop-overlay">
    <div class="big">Image</div>
    <div class="txt">Drop your image here</div>
  </div>

  <div id="imgModal" class="modal" aria-hidden="true">
    <button id="closeModalBtn" title="Close">âœ•</button>
    <img id="modalImg" alt="preview" />
  </div>

  <script>
    // ---------- State ----------
    const state = {
      pendingFile: null,          // current upload
      pendingPreviewUrl: null,    // objectURL for preview
      lastPack: null,             // { full, crops:[{label,dataUrl}], displayUrl }
      busy: false
    };

    // ---------- Elements ----------
    const chatEl = document.getElementById('chat');
    const welcomeEl = document.getElementById('welcome');
    const previewEl = document.getElementById('preview');
    const textInputEl = document.getElementById('textInput');
    const imageBtnEl = document.getElementById('imageBtn');
    const webBtnEl = document.getElementById('webBtn');
    const sendBtnEl = document.getElementById('sendBtn');
    const fileInputEl = document.getElementById('fileInput');
    const modelSelectEl = document.getElementById('modelSelect');
    const dropOverlayEl = document.getElementById('dropOverlay');
    const ultraToggleEl = document.getElementById('ultraToggle');

    const imgModalEl = document.getElementById('imgModal');
    const modalImgEl = document.getElementById('modalImg');
    const closeModalBtnEl = document.getElementById('closeModalBtn');

    // ---------- Prompts ----------
    const VISION_SYSTEM = `
You are a highly accurate vision assistant.
Rules:
- Describe ONLY what you can actually see. If unsure, say "not clear" and ask a question.
- Use zoomed crops to capture minute details.
- If text is visible, transcribe it exactly with line breaks. Use [?] for unclear characters.
- Be specific: counts, colors, locations, small logos/icons/UI labels.
- Answer the user's question FIRST, then provide extra relevant details.
`.trim();

    const WEB_QUERY_PROMPT = `
You are generating a reverse-image-search style query.
Given the image(s), output ONE concise Google query that would identify it.
Include:
- exact text visible (brand/model/product name)
- distinctive attributes (color, shape, logo, packaging, character name, UI app name)
Rules:
- Output ONLY the query text. No quotes, no markdown, no explanations.
- Keep it under 12 words if possible.
`.trim();

    // ---------- Helpers ----------
    function autosizeTextarea(){
      textInputEl.style.height = 'auto';
      textInputEl.style.height = Math.min(textInputEl.scrollHeight, 180) + 'px';
    }

    function escapeHtml(s){
      return (s || '').replace(/[&<>"']/g, c => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));
    }

    function formatBasicMarkdownToHtml(text){
      let t = escapeHtml(text || '');
      t = t.replace(/```[\s\S]*?```/g, (m) => {
        const inner = m.slice(3, -3).replace(/^\w+\n/, '');
        return `<pre><code>${inner.trim()}</code></pre>`;
      });
      t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
      t = t.replace(/\n/g, '<br>');
      return t;
    }

    function addMessage({ role, text, imageUrls = [] }){
      welcomeEl.style.display = 'none';

      const msg = document.createElement('div');
      msg.className = 'msg';

      const avatar = document.createElement('div');
      avatar.className = 'avatar ' + (role === 'assistant' ? 'assistant' : 'user');
      avatar.textContent = role === 'assistant' ? 'âœ¦' : 'ðŸ‘¤';

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span class="name">${role === 'assistant' ? 'Claude' : 'You'}</span>`;

      const content = document.createElement('div');
      content.className = 'content';
      content.innerHTML = formatBasicMarkdownToHtml(text || '');

      bubble.appendChild(meta);

      if (imageUrls.length){
        const row = document.createElement('div');
        row.className = 'images-row';
        for (const url of imageUrls){
          const img = document.createElement('img');
          img.className = 'thumb';
          img.src = url;
          img.alt = 'image';
          img.addEventListener('click', () => openModal(url));
          row.appendChild(img);
        }
        bubble.appendChild(row);
      }

      bubble.appendChild(content);
      msg.appendChild(avatar);
      msg.appendChild(bubble);

      chatEl.appendChild(msg);
      chatEl.scrollTop = chatEl.scrollHeight;

      return { contentEl: content };
    }

    function openModal(src){
      modalImgEl.src = src;
      imgModalEl.classList.add('active');
      imgModalEl.setAttribute('aria-hidden', 'false');
    }

    function closeModal(){
      imgModalEl.classList.remove('active');
      imgModalEl.setAttribute('aria-hidden', 'true');
      modalImgEl.src = '';
    }

    function renderPreview(){
      if (state.pendingPreviewUrl){
        URL.revokeObjectURL(state.pendingPreviewUrl);
        state.pendingPreviewUrl = null;
      }

      previewEl.innerHTML = '';
      if (!state.pendingFile){
        previewEl.classList.remove('active');
        return;
      }

      previewEl.classList.add('active');
      const url = URL.createObjectURL(state.pendingFile);
      state.pendingPreviewUrl = url;

      const item = document.createElement('div');
      item.className = 'preview-item';

      const img = document.createElement('img');
      img.src = url;
      img.alt = 'preview';
      img.addEventListener('click', () => openModal(url));

      const rm = document.createElement('button');
      rm.className = 'preview-remove';
      rm.textContent = 'Ã—';
      rm.addEventListener('click', () => {
        state.pendingFile = null;
        renderPreview();
      });

      item.appendChild(img);
      item.appendChild(rm);
      previewEl.appendChild(item);
    }

    async function addFile(file){
      if (!file || !file.type || !file.type.startsWith('image/')) return;
      state.pendingFile = file; // keep single image for max detail
      renderPreview();
    }

    // ---------- Image processing (full + crops) ----------
    async function fileToBitmap(file){
      try {
        return await createImageBitmap(file, { imageOrientation: 'from-image' });
      } catch {
        const dataUrl = await fileToDataUrl(file);
        const img = await dataUrlToImage(dataUrl);
        return img;
      }
    }

    function fileToDataUrl(file){
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(new Error('Failed reading file'));
        r.readAsDataURL(file);
      });
    }

    function dataUrlToImage(dataUrl){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to decode image'));
        img.src = dataUrl;
      });
    }

    function resizeToCanvas(drawable, maxSide = 2200){
      const srcW = drawable.width;
      const srcH = drawable.height;
      const scale = Math.min(1, maxSide / Math.max(srcW, srcH));
      const w = Math.max(1, Math.round(srcW * scale));
      const h = Math.max(1, Math.round(srcH * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha:false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(drawable, 0, 0, w, h);
      return canvas;
    }

    function canvasToJpegDataUrl(canvas, quality = 0.95){
      return canvas.toDataURL('image/jpeg', quality);
    }

    function cropCanvasToDataUrl(srcCanvas, x, y, w, h, quality=0.95){
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d', { alpha:false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(srcCanvas, x, y, w, h, 0, 0, w, h);
      return canvasToJpegDataUrl(c, quality);
    }

    function dataUrlToParts(dataUrl){
      const m = dataUrl.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,(.+)$/);
      if (!m) throw new Error('Invalid image data URL');
      return { media_type: m[1], data: m[2] };
    }

    function makeImageBlock(dataUrl){
      const parts = dataUrlToParts(dataUrl);
      return {
        type: 'image',
        source: { type:'base64', media_type: parts.media_type, data: parts.data }
      };
    }

    async function buildPack(file, ultra=true){
      const bmp = await fileToBitmap(file);
      const baseCanvas = resizeToCanvas(bmp, 2200);
      const full = canvasToJpegDataUrl(baseCanvas, 0.95);

      const W = baseCanvas.width, H = baseCanvas.height;
      const crops = [];

      if (ultra){
        const halfW = Math.floor(W/2), halfH = Math.floor(H/2);
        crops.push({ label: "TL", dataUrl: cropCanvasToDataUrl(baseCanvas, 0, 0, halfW, halfH) });
        crops.push({ label: "TR", dataUrl: cropCanvasToDataUrl(baseCanvas, halfW, 0, W-halfW, halfH) });
        crops.push({ label: "BL", dataUrl: cropCanvasToDataUrl(baseCanvas, 0, halfH, halfW, H-halfH) });
        crops.push({ label: "BR", dataUrl: cropCanvasToDataUrl(baseCanvas, halfW, halfH, W-halfW, H-halfH) });

        const cx = Math.floor(W*0.25), cy = Math.floor(H*0.25);
        const cw = Math.floor(W*0.5), ch = Math.floor(H*0.5);
        crops.push({ label: "CENTER", dataUrl: cropCanvasToDataUrl(baseCanvas, cx, cy, cw, ch) });
      }

      const displayUrl = URL.createObjectURL(file);
      return { full, crops, displayUrl };
    }

    // ---------- Model calls ----------
    async function callVision({ model, userText, pack, ultra }){
      const blocks = [];
      blocks.push({ type:'text', text:'[FULL]' });
      blocks.push(makeImageBlock(pack.full));

      if (ultra){
        for (const c of pack.crops){
          blocks.push({ type:'text', text:`[CROP ${c.label}]` });
          blocks.push(makeImageBlock(c.dataUrl));
        }
      }

      const prompt =
`${VISION_SYSTEM}

USER REQUEST:
${userText || "Describe the image in ultra detail."}

OUTPUT:
1) Direct answer first.
2) Minute details (cite FULL/TL/TR/BL/BR/CENTER when possible).
3) Text found (verbatim).
4) Uncertain items (no guessing).`;

      blocks.push({ type:'text', text: prompt });

      const messages = [{ role:'user', content: blocks }];
      return await puter.ai.chat(messages, { model, stream:true });
    }

    async function callVisionForQuery({ model, pack, ultra }){
      const blocks = [];
      blocks.push({ type:'text', text:'[FULL]' });
      blocks.push(makeImageBlock(pack.full));

      // For query generation, sending CENTER crop helps a lot.
      if (ultra && pack.crops?.length){
        const center = pack.crops.find(x => x.label === "CENTER") || pack.crops[pack.crops.length - 1];
        blocks.push({ type:'text', text:'[CROP CENTER]' });
        blocks.push(makeImageBlock(center.dataUrl));
      }

      blocks.push({ type:'text', text: WEB_QUERY_PROMPT });

      const messages = [{ role:'user', content: blocks }];
      return await puter.ai.chat(messages, { model, stream:true });
    }

    // Wikipedia OpenSearch (free, CORS allowed)
    async function wikiSearch(query){
      const url =
        "https://en.wikipedia.org/w/api.php?action=opensearch&format=json&origin=*&limit=5&search=" +
        encodeURIComponent(query);
      const r = await fetch(url);
      if (!r.ok) return null;
      const data = await r.json();
      // data = [query, titles[], desc[], links[]]
      return data;
    }

    // ---------- Send message ----------
    async function send(){
      if (state.busy) return;

      const userText = (textInputEl.value || '').trim();
      const ultra = !!ultraToggleEl.checked;

      // Use newly uploaded image if present, else reuse last image for follow-ups
      const hasNew = !!state.pendingFile;
      const hasLast = !!state.lastPack;

      if (!userText && !hasNew && !hasLast) return;

      state.busy = true;
      sendBtnEl.disabled = true;

      let pack = null;

      try {
        if (hasNew){
          pack = await buildPack(state.pendingFile, ultra);
          state.lastPack = pack;
          state.pendingFile = null;
          renderPreview();
        } else {
          pack = state.lastPack;
        }

        addMessage({
          role:'user',
          text: userText || (pack ? "Analyze this image in ultra detail." : "Hi"),
          imageUrls: pack ? [pack.displayUrl] : []
        });

        textInputEl.value = '';
        autosizeTextarea();

        const assistant = addMessage({ role:'assistant', text:'' });
        let out = '';

        const model = modelSelectEl.value;
        const stream = pack
          ? await callVision({ model, userText, pack, ultra })
          : await puter.ai.chat(userText, { model, stream:true });

        for await (const part of stream){
          if (part?.text){
            out += part.text;
            assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(out);
            chatEl.scrollTop = chatEl.scrollHeight;
          }
        }

        if (!out.trim()){
          assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(
            "No output received. Try again or switch models (e.g., GPT-4o backup)."
          );
        }
      } catch (err){
        addMessage({
          role:'assistant',
          text: `Error: ${err?.message || err}\n\nTry switching to GPT-4o (backup) if a Claude model is acting weird.`
        });
        console.error(err);
      } finally {
        state.busy = false;
        sendBtnEl.disabled = false;
        textInputEl.focus();
      }
    }

    // ---------- Web lookup (Google open + Wikipedia hints) ----------
    async function webLookup(){
      if (state.busy) return;

      const ultra = !!ultraToggleEl.checked;
      const hasNew = !!state.pendingFile;
      const hasLast = !!state.lastPack;

      if (!hasNew && !hasLast){
        addMessage({ role:'assistant', text: "Upload an image first, then press Web." });
        return;
      }

      state.busy = true;
      webBtnEl.disabled = true;

      try {
        let pack;
        if (hasNew){
          pack = await buildPack(state.pendingFile, ultra);
          state.lastPack = pack;
          state.pendingFile = null;
          renderPreview();

          addMessage({
            role:'user',
            text: "Web lookup this image.",
            imageUrls: [pack.displayUrl]
          });
        } else {
          pack = state.lastPack;
          addMessage({
            role:'user',
            text: "Web lookup this image (reuse last).",
            imageUrls: [pack.displayUrl]
          });
        }

        const assistant = addMessage({ role:'assistant', text: "Generating a search query from the imageâ€¦" });
        const model = modelSelectEl.value;

        // Stream query
        let query = "";
        const stream = await callVisionForQuery({ model, pack, ultra });

        for await (const part of stream){
          if (part?.text){
            query += part.text;
            assistant.contentEl.innerHTML = formatBasicMarkdownToHtml("Query:\n" + query.trim());
          }
        }

        query = (query || "").trim().replace(/\s+/g, " ").slice(0, 120);
        if (!query){
          assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(
            "Could not generate a query. Try switching to GPT-4o (backup) and press Web again."
          );
          return;
        }

        // Wikipedia quick results
        let wikiBlock = "";
        try {
          const data = await wikiSearch(query);
          if (data && Array.isArray(data) && data.length >= 4){
            const titles = data[1] || [];
            const descs  = data[2] || [];
            const links  = data[3] || [];
            if (titles.length){
              wikiBlock += "\n\nWikipedia quick matches:\n";
              for (let i=0; i<titles.length; i++){
                wikiBlock += `- ${titles[i]} â€” ${descs[i] || ""}\n  ${links[i] || ""}\n`;
              }
            }
          }
        } catch {}

        const googleUrl = "https://www.google.com/search?q=" + encodeURIComponent(query);

        assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(
          `Query:\n${query}\n\nOpen Google:\n${googleUrl}${wikiBlock}\n\nTip: Open the results and paste the best match URL/title back here, and Iâ€™ll confirm.`
        );

        // Open Google in a new tab (user gesture from button click, so usually allowed)
        window.open(googleUrl, "_blank", "noopener,noreferrer");
      } catch (err){
        addMessage({ role:'assistant', text: `Error: ${err?.message || err}` });
        console.error(err);
      } finally {
        state.busy = false;
        webBtnEl.disabled = false;
        textInputEl.focus();
      }
    }

    // ---------- Events ----------
    imageBtnEl.addEventListener('click', () => fileInputEl.click());
    fileInputEl.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      await addFile(f);
      fileInputEl.value = '';
    });

    sendBtnEl.addEventListener('click', send);
    webBtnEl.addEventListener('click', webLookup);

    textInputEl.addEventListener('input', autosizeTextarea);
    textInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        send();
      }
    });

    // Paste images
    document.addEventListener('paste', async (e) => {
      const items = Array.from(e.clipboardData?.items || []);
      const imgItem = items.find(it => it.type && it.type.startsWith('image/'));
      if (!imgItem) return;
      e.preventDefault();
      await addFile(imgItem.getAsFile());
    });

    // Drag/drop overlay
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      dropOverlayEl.classList.add('active');
    });
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter = Math.max(0, dragCounter - 1);
      if (dragCounter === 0) dropOverlayEl.classList.remove('active');
    });
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      dragCounter = 0;
      dropOverlayEl.classList.remove('active');
      const f = e.dataTransfer?.files?.[0];
      await addFile(f);
    });

    // Modal close
    closeModalBtnEl.addEventListener('click', closeModal);
    imgModalEl.addEventListener('click', (e) => { if (e.target === imgModalEl) closeModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

    textInputEl.focus();
  </script>
</body>
</html>
