<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Claude Vision (Ultra)</title>

  <script src="https://js.puter.com/v2/"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0b0b0d; --panel:#111114; --panel2:#15151a; --border:#26262d;
      --text:#e9e9ef; --muted:#a1a1b3; --muted2:#707085;
      --accent:#d4a574; --danger:#ff6b6b; --ok:#4ade80;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 30% -10%, rgba(212,165,116,.12), transparent 60%),
        radial-gradient(1200px 800px at 90% 10%, rgba(128,90,213,.12), transparent 60%),
        var(--bg);
    }

    .topbar{
      position:sticky; top:0; z-index:10;
      backdrop-filter: blur(14px);
      background: rgba(11,11,13,.75);
      border-bottom:1px solid var(--border);
    }
    .topbar-inner{
      max-width:920px; margin:0 auto;
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{display:flex; align-items:center; gap:10px; font-weight:700}
    .badge{
      width:34px; height:34px; border-radius:10px;
      display:grid; place-items:center;
      background:linear-gradient(135deg,var(--accent),#b98257);
      color:#141414; font-weight:900;
    }
    select{
      appearance:none;
      background:var(--panel2);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:13px;
      outline:none;
    }
    select:hover{border-color:rgba(212,165,116,.55)}

    .wrap{
      max-width:920px; margin:0 auto;
      padding:18px 16px 24px;
      height:calc(100% - 64px);
      display:flex; flex-direction:column; gap:12px;
    }

    .chat{flex:1; overflow:auto; padding:6px 0 18px}
    .welcome{
      margin-top:40px;
      border:1px solid var(--border);
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
      border-radius:18px;
      padding:22px;
    }
    .welcome h1{margin:0 0 10px; font-size:22px}
    .welcome p{margin:0; color:var(--muted); line-height:1.55; font-size:14px}

    .msg{margin:18px 0; display:flex; gap:12px; align-items:flex-start}
    .avatar{
      width:34px; height:34px; border-radius:11px;
      display:grid; place-items:center;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      font-weight:800; user-select:none; flex:0 0 auto;
    }
    .avatar.assistant{
      background:linear-gradient(135deg,rgba(212,165,116,.95),rgba(185,130,87,.95));
      color:#131313; border-color:rgba(212,165,116,.35);
    }
    .bubble{flex:1 1 auto; min-width:0}
    .meta{display:flex; align-items:center; justify-content:space-between; margin-bottom:6px; font-size:12px; color:var(--muted2)}
    .meta .name{color:var(--text); font-weight:600; font-size:13px}
    .content{line-height:1.75; font-size:14px; white-space:pre-wrap; word-break:break-word}
    .content code{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      padding:2px 6px; border-radius:8px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:13px;
    }
    .content pre{
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.08);
      padding:12px; border-radius:14px;
      overflow:auto;
    }
    .images-row{display:flex; flex-wrap:wrap; gap:10px; margin:10px 0 8px}
    .thumb{
      width:220px; max-width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.02);
      object-fit:cover;
      cursor:pointer;
    }

    .composer{
      position:sticky; bottom:0;
      padding-top:10px;
      background:linear-gradient(180deg,transparent,rgba(11,11,13,.85) 30%,rgba(11,11,13,.95));
    }
    .composer-box{
      border:1px solid var(--border);
      background:rgba(17,17,20,.9);
      border-radius:18px;
      padding:14px;
    }
    .composer-box:focus-within{
      border-color:rgba(212,165,116,.55);
      box-shadow:0 0 0 3px rgba(212,165,116,.10);
    }

    .preview{
      display:none; gap:10px; flex-wrap:wrap;
      padding-bottom:12px; margin-bottom:12px;
      border-bottom:1px solid var(--border);
    }
    .preview.active{display:flex}
    .preview-item{
      position:relative; width:76px; height:76px;
      border-radius:14px; overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    .preview-item img{width:100%; height:100%; object-fit:cover; display:block}
    .preview-remove{
      position:absolute; top:-8px; right:-8px;
      width:24px; height:24px; border-radius:999px;
      border:none; background:var(--danger);
      color:#121212; font-weight:900; cursor:pointer;
    }

    .row{display:flex; gap:10px; align-items:flex-end}
    textarea{
      flex:1 1 auto;
      background:transparent; border:none; outline:none;
      color:var(--text);
      resize:none;
      font-size:14px; line-height:1.5;
      min-height:24px; max-height:180px;
      padding:2px 0;
    }
    textarea::placeholder{color:var(--muted2)}
    .btn{
      width:44px; height:44px;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      display:grid; place-items:center;
      font-size:14px; user-select:none;
    }
    .btn:hover{border-color:rgba(212,165,116,.55)}
    .btn-send{
      background:linear-gradient(135deg,var(--accent),#b98257);
      border-color:rgba(212,165,116,.50);
      color:#121212;
      font-weight:900;
      font-size:18px;
    }
    .btn-send:disabled{opacity:.55; cursor:not-allowed}

    .hint{
      margin-top:10px;
      color:var(--muted2);
      font-size:12px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      user-select:none;
    }
    .toggle input{accent-color:var(--accent)}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      user-select:none;
    }
    .dot{width:8px; height:8px; border-radius:99px; background:var(--muted2)}
    .dot.ok{background:var(--ok)}
    .dot.warn{background:var(--accent)}

    .drop-overlay{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center; flex-direction:column;
      background:rgba(11,11,13,.92);
      z-index:100;
      border:2px dashed rgba(212,165,116,.45);
    }
    .drop-overlay.active{display:flex}
    .drop-overlay .big{font-size:44px; margin-bottom:10px}
    .drop-overlay .txt{font-size:16px; color:var(--muted)}

    .modal{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.92);
      z-index:120;
      padding:24px;
    }
    .modal.active{display:flex}
    .modal img{
      max-width:100%; max-height:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.15);
      object-fit:contain;
    }
    .modal button{
      position:absolute; top:18px; right:18px;
      width:46px; height:46px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.06);
      color:var(--text);
      font-size:20px;
      cursor:pointer;
    }

    @media (max-width:700px){
      .thumb{width:100%}
      .topbar-inner{padding:12px}
      .wrap{padding:14px 12px 18px}
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand"><div class="badge">‚ú¶</div><div>Claude Vision</div></div>
      <div class="controls">
        <select id="modelSelect" title="Model">
          <option value="claude-opus-4-5">Claude Opus 4.5</option>
          <option value="claude-sonnet-4-5" selected>Claude Sonnet 4.5</option>
          <option value="claude-haiku-4-5">Claude Haiku 4.5</option>
          <option value="gpt-4o">GPT-4o (backup)</option>
        </select>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div id="chat" class="chat">
      <div class="welcome" id="welcome">
        <h1>Accurate ID + minute details</h1>
        <p>
          This sends the full image + zoomed crops (for tiny details). OCR runs in the background and never blocks Send.
          If Send ‚Äúdid nothing‚Äù before, this fixes it.
        </p>
      </div>
    </div>

    <div class="composer">
      <div class="composer-box">
        <div id="preview" class="preview"></div>

        <div class="row">
          <textarea id="textInput" rows="1" placeholder="Ask about the image‚Ä¶ (Enter to send, Shift+Enter newline)"></textarea>
          <button id="imageBtn" class="btn" title="Image">Image</button>
          <button id="sendBtn" class="btn btn-send" title="Send">‚û§</button>
        </div>

        <div class="hint">
          <span class="pill" title="OCR runs locally in your browser, optional">
            <span id="ocrDot" class="dot"></span>
            <span id="ocrText">OCR: idle</span>
          </span>

          <label class="toggle" title="Zoom crops + background OCR for more accuracy">
            <input id="boostToggle" type="checkbox" checked />
            Boost accuracy
          </label>
        </div>
      </div>
    </div>

    <input id="fileInput" type="file" accept="image/*" hidden />
  </div>

  <div id="dropOverlay" class="drop-overlay">
    <div class="big">Image</div>
    <div class="txt">Drop your image here</div>
  </div>

  <div id="imgModal" class="modal" aria-hidden="true">
    <button id="closeModalBtn" title="Close">‚úï</button>
    <img id="modalImg" alt="preview" />
  </div>

  <script>
    // ---------- State ----------
    const state = {
      pendingFile: null,
      pendingPreviewUrl: null,
      lastPack: null,       // { full, crops, displayUrl }
      lastOcrText: "",
      ocrRunning: false,
      tesseractLoaded: false,
      busy: false
    };

    // ---------- Elements ----------
    const chatEl = document.getElementById('chat');
    const welcomeEl = document.getElementById('welcome');
    const previewEl = document.getElementById('preview');
    const textInputEl = document.getElementById('textInput');
    const imageBtnEl = document.getElementById('imageBtn');
    const sendBtnEl = document.getElementById('sendBtn');
    const fileInputEl = document.getElementById('fileInput');
    const modelSelectEl = document.getElementById('modelSelect');
    const dropOverlayEl = document.getElementById('dropOverlay');
    const boostToggleEl = document.getElementById('boostToggle');

    const imgModalEl = document.getElementById('imgModal');
    const modalImgEl = document.getElementById('modalImg');
    const closeModalBtnEl = document.getElementById('closeModalBtn');

    const ocrDotEl = document.getElementById('ocrDot');
    const ocrTextEl = document.getElementById('ocrText');

    // ---------- Prompt (forces structure + non-guessing) ----------
    const VISION_SYSTEM = `
You are an elite image identification assistant.
Rules:
- DO NOT guess. If unsure, say what is uncertain and what detail is missing.
- Use the zoomed crops to verify minute details (small text/icons/logos/labels).
- OCR hints are extra evidence, but prefer visual confirmation.
- If text is visible, transcribe it exactly (preserve line breaks). Use [?] for unclear chars.
Output format (MUST):
1) IDENTIFICATION (best guess + short reason)
2) CONFIDENCE (0-100) + why not 100
3) MINUTE DETAILS (bullets, include tiny things)
4) TEXT FOUND (verbatim)
5) SEARCH QUERY (short Google query to confirm)
`.trim();

    // ---------- UI helpers ----------
    function autosizeTextarea(){
      textInputEl.style.height = 'auto';
      textInputEl.style.height = Math.min(textInputEl.scrollHeight, 180) + 'px';
    }
    function escapeHtml(s){
      return (s || '').replace(/[&<>"']/g, c => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));
    }
    function formatBasicMarkdownToHtml(text){
      let t = escapeHtml(text || '');
      t = t.replace(/```[\s\S]*?```/g, (m) => {
        const inner = m.slice(3, -3).replace(/^\w+\n/, '');
        return `<pre><code>${inner.trim()}</code></pre>`;
      });
      t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
      t = t.replace(/\n/g, '<br>');
      return t;
    }
    function addMessage({ role, text, imageUrls = [] }){
      welcomeEl.style.display = 'none';

      const msg = document.createElement('div');
      msg.className = 'msg';

      const avatar = document.createElement('div');
      avatar.className = 'avatar ' + (role === 'assistant' ? 'assistant' : 'user');
      avatar.textContent = role === 'assistant' ? '‚ú¶' : 'üë§';

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span class="name">${role === 'assistant' ? 'Claude' : 'You'}</span>`;

      const content = document.createElement('div');
      content.className = 'content';
      content.innerHTML = formatBasicMarkdownToHtml(text || '');

      bubble.appendChild(meta);

      if (imageUrls.length){
        const row = document.createElement('div');
        row.className = 'images-row';
        for (const url of imageUrls){
          const img = document.createElement('img');
          img.className = 'thumb';
          img.src = url;
          img.alt = 'image';
          img.addEventListener('click', () => openModal(url));
          row.appendChild(img);
        }
        bubble.appendChild(row);
      }

      bubble.appendChild(content);

      msg.appendChild(avatar);
      msg.appendChild(bubble);

      chatEl.appendChild(msg);
      chatEl.scrollTop = chatEl.scrollHeight;

      return { contentEl: content };
    }

    function openModal(src){
      modalImgEl.src = src;
      imgModalEl.classList.add('active');
      imgModalEl.setAttribute('aria-hidden', 'false');
    }
    function closeModal(){
      imgModalEl.classList.remove('active');
      imgModalEl.setAttribute('aria-hidden', 'true');
      modalImgEl.src = '';
    }

    function setOcrStatus(kind, text){
      ocrTextEl.textContent = text;
      ocrDotEl.classList.remove('ok','warn');
      if (kind === 'ok') ocrDotEl.classList.add('ok');
      if (kind === 'warn') ocrDotEl.classList.add('warn');
    }

    // ---------- Preview ----------
    function renderPreview(){
      if (state.pendingPreviewUrl){
        URL.revokeObjectURL(state.pendingPreviewUrl);
        state.pendingPreviewUrl = null;
      }
      previewEl.innerHTML = '';

      if (!state.pendingFile){
        previewEl.classList.remove('active');
        return;
      }
      previewEl.classList.add('active');

      const url = URL.createObjectURL(state.pendingFile);
      state.pendingPreviewUrl = url;

      const item = document.createElement('div');
      item.className = 'preview-item';

      const img = document.createElement('img');
      img.src = url;
      img.alt = 'preview';
      img.addEventListener('click', () => openModal(url));

      const rm = document.createElement('button');
      rm.className = 'preview-remove';
      rm.textContent = '√ó';
      rm.addEventListener('click', () => {
        state.pendingFile = null;
        state.lastOcrText = "";
        state.ocrRunning = false;
        setOcrStatus('', 'OCR: idle');
        renderPreview();
      });

      item.appendChild(img);
      item.appendChild(rm);
      previewEl.appendChild(item);
    }

    async function addFile(file){
      if (!file || !file.type || !file.type.startsWith('image/')) return;
      state.pendingFile = file;
      renderPreview();

      // start OCR in background (DO NOT BLOCK SEND)
      if (boostToggleEl.checked) startOcrInBackground(file);
      else {
        state.lastOcrText = "";
        setOcrStatus('', 'OCR: idle');
      }
    }

    // ---------- Image normalize + crops ----------
    async function fileToBitmap(file){
      try {
        return await createImageBitmap(file, { imageOrientation: 'from-image' });
      } catch {
        const dataUrl = await fileToDataUrl(file);
        const img = await dataUrlToImage(dataUrl);
        return img;
      }
    }
    function fileToDataUrl(file){
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(new Error('Failed reading file'));
        r.readAsDataURL(file);
      });
    }
    function dataUrlToImage(dataUrl){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to decode image'));
        img.src = dataUrl;
      });
    }
    function resizeToCanvas(drawable, maxSide = 2400){
      const srcW = drawable.width, srcH = drawable.height;
      const scale = Math.min(1, maxSide / Math.max(srcW, srcH));
      const w = Math.max(1, Math.round(srcW * scale));
      const h = Math.max(1, Math.round(srcH * scale));

      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha:false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(drawable, 0, 0, w, h);
      return canvas;
    }
    function canvasToJpegDataUrl(canvas, quality=0.95){
      return canvas.toDataURL('image/jpeg', quality);
    }
    function cropCanvasToDataUrl(srcCanvas, x, y, w, h, quality=0.95){
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d', { alpha:false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(srcCanvas, x, y, w, h, 0, 0, w, h);
      return canvasToJpegDataUrl(c, quality);
    }

    async function buildPack(file, boost=true){
      const bmp = await fileToBitmap(file);
      const baseCanvas = resizeToCanvas(bmp, 2400);
      const full = canvasToJpegDataUrl(baseCanvas, 0.95);

      const crops = [];
      if (boost){
        const W = baseCanvas.width, H = baseCanvas.height;
        const halfW = Math.floor(W/2), halfH = Math.floor(H/2);

        crops.push({ label:"TL", dataUrl: cropCanvasToDataUrl(baseCanvas, 0, 0, halfW, halfH) });
        crops.push({ label:"TR", dataUrl: cropCanvasToDataUrl(baseCanvas, halfW, 0, W-halfW, halfH) });
        crops.push({ label:"BL", dataUrl: cropCanvasToDataUrl(baseCanvas, 0, halfH, halfW, H-halfH) });
        crops.push({ label:"BR", dataUrl: cropCanvasToDataUrl(baseCanvas, halfW, halfH, W-halfW, H-halfH) });

        const cx = Math.floor(W*0.25), cy = Math.floor(H*0.25);
        const cw = Math.floor(W*0.5), ch = Math.floor(H*0.5);
        crops.push({ label:"CENTER", dataUrl: cropCanvasToDataUrl(baseCanvas, cx, cy, cw, ch) });
      }

      // Display URL for chat (revoke previous when replacing)
      if (state.lastPack?.displayUrl) {
        try { URL.revokeObjectURL(state.lastPack.displayUrl); } catch {}
      }
      const displayUrl = URL.createObjectURL(file);

      return { full, crops, displayUrl };
    }

    function dataUrlToParts(dataUrl){
      const m = dataUrl.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,(.+)$/);
      if (!m) throw new Error('Invalid image data URL');
      return { media_type: m[1], data: m[2] };
    }
    function makeImageBlock(dataUrl){
      const parts = dataUrlToParts(dataUrl);
      return { type:'image', source:{ type:'base64', media_type: parts.media_type, data: parts.data } };
    }

    // ---------- Background OCR (never blocks sending) ----------
    async function loadTesseractOnce(){
      if (window.Tesseract) return;
      if (state.tesseractLoaded) return;
      state.tesseractLoaded = true;

      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js";
        s.onload = resolve;
        s.onerror = () => reject(new Error("Failed to load Tesseract.js (blocked?)"));
        document.head.appendChild(s);
      });
    }

    async function startOcrInBackground(file){
      if (state.ocrRunning) return;
      state.ocrRunning = true;
      state.lastOcrText = "";

      try {
        setOcrStatus('warn', 'OCR: running‚Ä¶');

        await loadTesseractOnce();

        // Small normalized image for OCR speed
        const bmp = await fileToBitmap(file);
        const ocrCanvas = resizeToCanvas(bmp, 1600);
        const ocrDataUrl = canvasToJpegDataUrl(ocrCanvas, 0.9);

        const worker = await Tesseract.createWorker({ logger: () => {} });
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        const { data } = await worker.recognize(ocrDataUrl);
        await worker.terminate();

        state.lastOcrText = (data?.text || "").trim();
        setOcrStatus('ok', state.lastOcrText ? 'OCR: ready' : 'OCR: ready (no text)');
      } catch (e) {
        console.error(e);
        setOcrStatus('', 'OCR: failed');
      } finally {
        state.ocrRunning = false;
      }
    }

    // ---------- Model call ----------
    async function callVision({ model, userText, pack, boost, ocrText }){
      const blocks = [];

      blocks.push({ type:'text', text:'[FULL]' });
      blocks.push(makeImageBlock(pack.full));

      if (boost){
        for (const c of pack.crops){
          blocks.push({ type:'text', text:`[CROP ${c.label}]` });
          blocks.push(makeImageBlock(c.dataUrl));
        }
      }

      if (boost && ocrText){
        blocks.push({ type:'text', text:`[OCR HINTS]\n${ocrText}` });
      }

      const prompt =
`${VISION_SYSTEM}

USER REQUEST:
${userText || "What is this image? Identify it accurately."}`;

      blocks.push({ type:'text', text: prompt });

      return await puter.ai.chat([{ role:'user', content: blocks }], { model, stream:true });
    }

    function extractSearchQuery(out){
      const m = out.match(/SEARCH QUERY\s*:\s*(.+)/i);
      return m ? m[1].trim().replace(/\s+/g,' ').slice(0, 200) : null;
    }

    // ---------- Send ----------
    async function send(){
      if (state.busy) return;

      const userText = (textInputEl.value || '').trim();
      const boost = !!boostToggleEl.checked;

      const hasNew = !!state.pendingFile;
      const hasLast = !!state.lastPack;

      if (!userText && !hasNew && !hasLast) return;

      state.busy = true;
      sendBtnEl.disabled = true;

      try {
        let pack = null;

        if (hasNew){
          pack = await buildPack(state.pendingFile, boost);
          state.lastPack = pack;

          // keep OCR result if it finishes later; send uses whatever is ready now
          state.pendingFile = null;
          renderPreview();
        } else {
          pack = state.lastPack;
        }

        addMessage({
          role:'user',
          text: userText || "Identify this image and describe tiny details.",
          imageUrls: pack ? [pack.displayUrl] : []
        });

        textInputEl.value = '';
        autosizeTextarea();

        const assistant = addMessage({ role:'assistant', text:'' });
        let out = '';

        const model = modelSelectEl.value;

        const stream = pack
          ? await callVision({
              model,
              userText,
              pack,
              boost,
              ocrText: state.lastOcrText // whatever is ready now (non-blocking)
            })
          : await puter.ai.chat(userText, { model, stream:true });

        for await (const part of stream){
          if (part?.text){
            out += part.text;
            assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(out);
            chatEl.scrollTop = chatEl.scrollHeight;
          }
        }

        const q = extractSearchQuery(out);
        if (q) {
          const url = "https://www.google.com/search?q=" + encodeURIComponent(q);
          assistant.contentEl.innerHTML += `<br><br><span style="color:var(--muted2)">Confirm on web:</span><br><a href="${url}" target="_blank" rel="noopener noreferrer" style="color:var(--accent)">${escapeHtml(url)}</a>`;
        }

        if (!out.trim()){
          assistant.contentEl.innerHTML = formatBasicMarkdownToHtml(
            "No output received. Try switching the model (GPT-4o backup is often strongest for vision)."
          );
        }
      } catch (err){
        addMessage({
          role:'assistant',
          text: `Error: ${err?.message || err}\n\nIf this persists: disable Boost, try a smaller JPG/PNG, or switch to GPT-4o backup.`
        });
        console.error(err);
      } finally {
        state.busy = false;
        sendBtnEl.disabled = false;
        textInputEl.focus();
      }
    }

    // ---------- Events ----------
    imageBtnEl.addEventListener('click', () => fileInputEl.click());
    fileInputEl.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      await addFile(f);
      fileInputEl.value = '';
    });

    sendBtnEl.addEventListener('click', send);

    textInputEl.addEventListener('input', autosizeTextarea);
    textInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        send();
      }
    });

    // paste image
    document.addEventListener('paste', async (e) => {
      const items = Array.from(e.clipboardData?.items || []);
      const imgItem = items.find(it => it.type && it.type.startsWith('image/'));
      if (!imgItem) return;
      e.preventDefault();
      await addFile(imgItem.getAsFile());
    });

    // drag/drop overlay
    let dragCounter = 0;
    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      dropOverlayEl.classList.add('active');
    });
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter = Math.max(0, dragCounter - 1);
      if (dragCounter === 0) dropOverlayEl.classList.remove('active');
    });
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      dragCounter = 0;
      dropOverlayEl.classList.remove('active');
      const f = e.dataTransfer?.files?.[0];
      await addFile(f);
    });

    // modal close
    closeModalBtnEl.addEventListener('click', closeModal);
    imgModalEl.addEventListener('click', (e) => { if (e.target === imgModalEl) closeModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

    // initial
    setOcrStatus('', 'OCR: idle');
    textInputEl.focus();
  </script>
</body>
</html>
